<!doctype html>
<html lang="zh">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vision Correction — PSF + Richardson-Lucy Demo</title>
  <style>
    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      margin: 18px;
      background: #f4f6f9;
      color: #111;
    }

    h1 {
      font-size: 18px;
      margin: 0 0 8px 0;
    }

    .wrap {
      display: flex;
      gap: 16px;
      align-items: flex-start;
    }

    .left {
      flex: 1;
      max-width: 900px;
    }

    canvas {
      background: #fff;
      width: 100%;
      height: auto;
      border-radius: 8px;
      box-shadow: 0 8px 24px rgba(20, 20, 40, 0.06);
    }

    .controls {
      width: 340px;
      padding: 12px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 6px 18px rgba(20, 20, 40, 0.06);
    }

    label {
      display: block;
      font-size: 13px;
      margin-top: 10px;
    }

    input[type="range"] {
      width: 100%;
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .small {
      font-size: 12px;
      color: #555;
      margin-top: 6px;
    }

    button {
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #ddd;
      background: #fff;
      cursor: pointer;
    }

    footer {
      margin-top: 12px;
      font-size: 12px;
      color: #666;
    }

    .muted {
      color: #666;
      font-size: 13px;
    }

    .flexcol {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
  </style>
</head>

<body>
  <h1>视觉矫正（PSF 反卷积）演示</h1>
  <div class="wrap">
    <div class="left">
      <canvas id="displayCanvas" width="1024" height="640"></canvas>
      <div class="small">上图：左为 <b>原始目标</b>（目标我们希望用户看到的清晰图），中间为 <b>预扭曲显示图</b>（要在屏幕上显示的图），右为 <b>眼睛看到的模拟</b>（显示图经过 PSF
        模糊后的结果）。</div>
    </div>

    <div class="controls">
      <div class="flexcol">
        <label>（输入以屈光度 D，近视用负数表示）</label>

        <label>球镜（Sph，D）：
          <input id="sph" type="range" min="-2000" max="1000" step="25" value="-1000">
          <div class="row">
            <div class="muted">Sph: <span id="sphVal">-1000</span> D</div>
          </div>
        </label>

        <label>柱镜（Cyl，D，散光强度）：
          <input id="cyl" type="range" min="0" max="1500" step="25" value="800">
          <div class="row">
            <div class="muted">Cyl: <span id="cylVal">800</span> D</div>
          </div>
        </label>

        <label>柱镜轴位（Axis，°）：
          <input id="axis" type="range" min="0" max="180" step="1" value="90">
          <div class="row">
            <div class="muted">Axis: <span id="axisVal">90</span>°</div>
          </div>
        </label>

        <label>观看距离（cm）：
          <input id="dist" type="range" min="10" max="120" step="1" value="40">
          <div class="row">
            <div class="muted">Dist: <span id="distVal">40</span> cm</div>
          </div>
        </label>

        <label>处理分辨率（越高越慢，建议 256–800）：
          <input id="procW" type="range" min="128" max="900" step="64" value="360">
          <div class="row">
            <div class="muted">Proc width: <span id="procWVal">360</span> px</div>
          </div>
        </label>

        <label>RL 迭代次数：
          <input id="iters" type="range" min="1" max="60" step="1" value="20">
          <div class="row">
            <div class="muted">Iterations: <span id="itersVal">20</span></div>
          </div>
        </label>

        <label>噪音/稳定因子（越大越稳但细节受损）：
          <input id="eps" type="range" min="0" max="0.05" step="0.001" value="0.002">
          <div class="row">
            <div class="muted">eps: <span id="epsVal">0.002</span></div>
          </div>
        </label>

        <label>上传目标（清晰）图片：
          <input id="file" type="file" accept="image/*">
        </label>

        <div class="row" style="margin-top:8px;">
          <button id="run">Compute corrected image</button>
          <button id="reset">Reset</button>
        </div>

        <footer>
          说明：此程序将对 <b>目标清晰图</b> 做去卷积（反演 PSF），得到用于显示的“预扭曲图”。随后显示“眼睛看到的模拟”，你可以调整参数观察差异。实验性工具，仅供研究/演示。
        </footer>
      </div>
    </div>
  </div>

  <script>
    // ======================= 工具函数 =======================
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function create2DArray(w, h, val = 0) { const a = new Array(h); for (let y = 0; y < h; y++) { a[y] = new Float32Array(w); if (val !== 0) for (let x = 0; x < w; x++)a[y][x] = val; } return a; }

    // 将 ImageData -> Float32 arrays per channel (normalized 0..1)
    function imageDataToArrays(imgd) {
      const w = imgd.width, h = imgd.height;
      const r = new Float32Array(w * h), g = new Float32Array(w * h), b = new Float32Array(w * h);
      for (let i = 0, p = 0; i < r.length; i++, p += 4) {
        r[i] = imgd.data[p] / 255;
        g[i] = imgd.data[p + 1] / 255;
        b[i] = imgd.data[p + 2] / 255;
      }
      return { r, g, b, w, h };
    }
    function arraysToImageData(channels, w, h) {
      const id = new ImageData(w, h);
      const r = channels.r, g = channels.g, b = channels.b;
      for (let i = 0, p = 0; i < r.length; i++, p += 4) {
        id.data[p] = clamp(Math.round(r[i] * 255), 0, 255);
        id.data[p + 1] = clamp(Math.round(g[i] * 255), 0, 255);
        id.data[p + 2] = clamp(Math.round(b[i] * 255), 0, 255);
        id.data[p + 3] = 255;
      }
      return id;
    }

    // 生成椭圆高斯 PSF 核（中心对齐），大小由 sigma 与 truncation 控制
    function makeEllipticalPSF(widthPx, sigmaX, sigmaY, angleRad, trunc = 3) {
      // kernel size: cover trunc * max(sigma)
      const maxSigma = Math.max(sigmaX, sigmaY);
      const half = Math.ceil(trunc * maxSigma);
      const size = half * 2 + 1;
      const kern = new Float32Array(size * size);
      const cx = half, cy = half;
      let sum = 0;
      const cosA = Math.cos(angleRad), sinA = Math.sin(angleRad);
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          // rotate point relative to center by -angle to align with ellipse axes
          const rx = x - cx, ry = y - cy;
          // rotated coordinates
          const ux = rx * cosA + ry * sinA;
          const uy = -rx * sinA + ry * cosA;
          const val = Math.exp(-0.5 * ((ux * ux) / (sigmaX * sigmaX) + (uy * uy) / (sigmaY * sigmaY)));
          kern[y * size + x] = val;
          sum += val;
        }
      }
      // normalize
      if (sum <= 0) return { k: kern, size };
      for (let i = 0; i < kern.length; i++) kern[i] /= sum;
      return { k: kern, size };
    }

    // 边界处理：mirror padding index
    function idxClamp(xx, max) { if (xx < 0) return -xx; if (xx >= max) return max - (xx - max) - 1; return xx; }

    // 空间卷积（图像 channel 是 Float32Array 长度 w*h），核为 {k,size}
    // 注意：此函数速度不是最快（直接空间卷积），但对较小处理分辨率与中等核大小可以接受
    function convolveChannel(channel, w, h, psf) {
      const k = psf.k, ks = psf.size, half = Math.floor(ks / 2);
      const out = new Float32Array(w * h);
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          let s = 0;
          for (let ky = 0; ky < ks; ky++) {
            const yy = idxClamp(y + (ky - half), h);
            const base = yy * w;
            for (let kx = 0; kx < ks; kx++) {
              const xx = idxClamp(x + (kx - half), w);
              s += channel[base + xx] * k[ky * ks + kx];
            }
          }
          out[y * w + x] = s;
        }
      }
      return out;
    }

    // element-wise operations for RL
    function multiplyInPlace(a, b) { for (let i = 0; i < a.length; i++) a[i] *= b[i]; }
    function divideArraysSafe(a, b, eps) { const r = new Float32Array(a.length); for (let i = 0; i < a.length; i++) r[i] = a[i] / (b[i] + eps); return r; }
    function copyArray(a) { const r = new Float32Array(a.length); r.set(a); return r; }

    // flip kernel (rotate 180°)
    function flipPSF(psf) {
      const k = psf.k, ks = psf.size;
      const fk = new Float32Array(k.length);
      for (let y = 0; y < ks; y++) {
        for (let x = 0; x < ks; x++) {
          fk[(ks - 1 - y) * ks + (ks - 1 - x)] = k[y * ks + x];
        }
      }
      return { k: fk, size: ks };
    }

    // ======================= 主流程 =======================
    const displayCanvas = document.getElementById('displayCanvas');
    const dctx = displayCanvas.getContext('2d');

    const sphIn = document.getElementById('sph');
    const cylIn = document.getElementById('cyl');
    const axisIn = document.getElementById('axis');
    const distIn = document.getElementById('dist');
    const procWIn = document.getElementById('procW');
    const itersIn = document.getElementById('iters');
    const epsIn = document.getElementById('eps');

    const sphVal = document.getElementById('sphVal');
    const cylVal = document.getElementById('cylVal');
    const axisVal = document.getElementById('axisVal');
    const distVal = document.getElementById('distVal');
    const procWVal = document.getElementById('procWVal');
    const itersVal = document.getElementById('itersVal');
    const epsVal = document.getElementById('epsVal');

    const fileInput = document.getElementById('file');
    const runBtn = document.getElementById('run');
    const resetBtn = document.getElementById('reset');

    // 默认示例图片（可替换）
    let sourceImg = new Image();
    sourceImg.crossOrigin = "anonymous";
    sourceImg.src = "https://upload.wikimedia.org/wikipedia/commons/4/47/PNG_transparency_demonstration_1.png";
    sourceImg.onload = () => drawUI();

    function drawUI() {
      // show labels
      sphVal.textContent = sphIn.value;
      cylVal.textContent = cylIn.value;
      axisVal.textContent = axisIn.value;
      distVal.textContent = distIn.value;
      procWVal.textContent = procWIn.value;
      itersVal.textContent = itersIn.value;
      epsVal.textContent = epsIn.value;

      // draw original image left (target), blank middle/right for now
      const W = displayCanvas.width, H = displayCanvas.height;
      dctx.clearRect(0, 0, W, H);
      // split into 3 panels
      const panelW = Math.floor(W / 3);
      // draw target scaled to panel
      dctx.fillStyle = "#ddd";
      dctx.fillRect(0, 0, panelW, H);
      dctx.drawImage(sourceImg, 0, 0, sourceImg.width, sourceImg.height, 0, 0, panelW, H);

      // middle: placeholder for pre-warped
      dctx.fillStyle = "#eee";
      dctx.fillRect(panelW, 0, panelW, H);
      dctx.fillStyle = "#999";
      dctx.fillText("预扭曲显示图（计算后显示）", panelW + 20, 20);

      // right: placeholder for eye-sim
      dctx.fillStyle = "#eee";
      dctx.fillRect(2 * panelW, 0, panelW, H);
      dctx.fillStyle = "#999";
      dctx.fillText("眼睛看到的模拟（显示图 * PSF）", 2 * panelW + 20, 20);
    }

    // 读取上传文件
    fileInput.addEventListener('change', (e) => {
      const f = e.target.files && e.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = evt => {
        sourceImg = new Image();
        sourceImg.crossOrigin = "anonymous";
        sourceImg.onload = () => drawUI();
        sourceImg.src = evt.target.result;
      };
      reader.readAsDataURL(f);
    });

    // 控件更新标签
    [sphIn, cylIn, axisIn, distIn, procWIn, itersIn, epsIn].forEach(el => {
      el.addEventListener('input', () => {
        sphVal.textContent = sphIn.value;
        cylVal.textContent = cylIn.value;
        axisVal.textContent = axisIn.value;
        distVal.textContent = distIn.value;
        procWVal.textContent = procWIn.value;
        itersVal.textContent = itersIn.value;
        epsVal.textContent = epsIn.value;
      });
    });

    // Reset 按钮
    resetBtn.addEventListener('click', () => {
      sphIn.value = -1000; cylIn.value = 800; axisIn.value = 90; distIn.value = 40;
      procWIn.value = 360; itersIn.value = 20; epsIn.value = 0.002;
      drawUI();
    });

    // 计算主流程
    runBtn.addEventListener('click', async () => {
      runBtn.disabled = true;
      runBtn.textContent = "计算中…（可能需要几秒）";
      await new Promise(r => setTimeout(r, 20)); // UI刷新

      try {
        await computeAndRender();
      } catch (e) {
        console.error(e);
        alert("计算出错: " + e.message);
      } finally {
        runBtn.disabled = false;
        runBtn.textContent = "Compute corrected image";
      }
    });

    async function computeAndRender() {
      // 1) 读取参数
      const sph = Number(sphIn.value);   // -2000..+1000 (D) 负为近视
      const cyl = Number(cylIn.value);   // 0..1500 (D) 散光
      const axis = Number(axisIn.value); // 0..180 deg
      const distCm = Number(distIn.value); // cm
      const procW = Number(procWIn.value); // processing width in px
      const iters = Number(itersIn.value);
      const eps = Number(epsIn.value);

      // 2) prepare target image in processing size (downscale for speed)
      const aspect = sourceImg.width / sourceImg.height;
      const procH = Math.max(16, Math.round(procW / aspect));
      const off = document.createElement('canvas'); off.width = procW; off.height = procH;
      const offCtx = off.getContext('2d');
      offCtx.fillStyle = "#fff";
      offCtx.fillRect(0, 0, procW, procH);
      offCtx.drawImage(sourceImg, 0, 0, sourceImg.width, sourceImg.height, 0, 0, procW, procH);

      const targetImgData = offCtx.getImageData(0, 0, procW, procH);
      const target = imageDataToArrays(targetImgData);

      // 3) 根据屈光度 & 距离 计算 PSF 参数（经验映射）
      // 映射思路（工程近似）：
      //  - 屈光度绝对值越大 => PSF 半径越大
      //  - 距离越近 => 屈光误差影响越强（乘以 40/dist）
      //  - 我们把 sigma_base (像素) = baseK * |Sph| * (40/dist) / scaleFactor
      //  - scaleFactor与处理分辨率与画面尺寸有关，选一个经验值使视觉上合理
      const baseK = 0.004; // 调参常数（可调整）
      const screenDiagPx = Math.sqrt(procW * procW + procH * procH);
      // convert diopters to pixel sigma
      const absSph = Math.abs(sph);
      const sigmaBase = Math.max(0.6, baseK * absSph * (40 / distCm) * (screenDiagPx / 600));
      // 将散光 (cyl) 分配为轴向不对称：sigmaX = sigmaBase*(1 + cylFactor), sigmaY = sigmaBase*(1 - cylFactor)
      const cylFactor = clamp(cyl / 1500, 0, 1); // 0..1
      // 为了更明显的效果把 cylStretch 放大一点
      const cylStretch = 0.9 * cylFactor;
      const sigmaX = Math.max(0.5, sigmaBase * (1 + cylStretch));
      const sigmaY = Math.max(0.5, sigmaBase * Math.max(0.06, 1 - cylStretch));

      // PSF size/truncation 控制
      const trunc = 3.5;
      const psf = makeEllipticalPSF(procW, sigmaX, sigmaY, axis * Math.PI / 180, trunc);
      const psfFlipped = flipPSF(psf);

      // 4) Richardson-Lucy 去卷积（对每通道独立）
      // 公式：
      //   est_{n+1} = est_n * [ (target / (est_n * PSF)) * PSF_flip ]
      // 初始化 est_0 = target (或均匀)，这里使用 target 克服零问题
      const outR = copyArray(target.r);
      const outG = copyArray(target.g);
      const outB = copyArray(target.b);

      // small eps to avoid division by zero
      const tiny = 1e-8;

      // Precompute normalization: ensure PSF sums to 1 (already normalized)
      // Iterations
      for (let it = 0; it < iters; it++) {
        // R
        // conv = est * PSF
        const convR = convolveChannel(outR, procW, procH, psf);
        const convG = convolveChannel(outG, procW, procH, psf);
        const convB = convolveChannel(outB, procW, procH, psf);

        // ratio = target / (conv + eps)
        const ratioR = new Float32Array(procW * procH);
        const ratioG = new Float32Array(procW * procH);
        const ratioB = new Float32Array(procW * procH);
        for (let i = 0; i < ratioR.length; i++) {
          ratioR[i] = target.r[i] / (convR[i] + eps + tiny);
          ratioG[i] = target.g[i] / (convG[i] + eps + tiny);
          ratioB[i] = target.b[i] / (convB[i] + eps + tiny);
        }

        // correction = ratio * PSF_flip  (i.e. convolve ratio with flipped PSF)
        const corrR = convolveChannel(ratioR, procW, procH, psfFlipped);
        const corrG = convolveChannel(ratioG, procW, procH, psfFlipped);
        const corrB = convolveChannel(ratioB, procW, procH, psfFlipped);

        // update estimate: est *= correction
        for (let i = 0; i < outR.length; i++) {
          outR[i] = Math.max(0, outR[i] * corrR[i]);
          outG[i] = Math.max(0, outG[i] * corrG[i]);
          outB[i] = Math.max(0, outB[i] * corrB[i]);
        }

        // optional: clamp and small normalization to reduce drift
        if ((it + 1) % 10 === 0) {
          const norm = 1.0;
          for (let i = 0; i < outR.length; i++) {
            outR[i] = clamp(outR[i], 0, 1);
            outG[i] = clamp(outG[i], 0, 1);
            outB[i] = clamp(outB[i], 0, 1);
          }
        }

        // tiny delay to keep UI responsive for heavy iterations
        if (it % 8 === 0) await new Promise(r => setTimeout(r, 0));
      }

      // 5) 得到预扭曲 displayImg = out*
      const displayChannels = { r: outR, g: outG, b: outB };
      const displayImgData = arraysToImageData(displayChannels, procW, procH);

      // 6) 计算“眼睛看到的模拟”：display * PSF
      const eyeR = convolveChannel(displayChannels.r, procW, procH, psf);
      const eyeG = convolveChannel(displayChannels.g, procW, procH, psf);
      const eyeB = convolveChannel(displayChannels.b, procW, procH, psf);
      const eyeImg = arraysToImageData({ r: eyeR, g: eyeG, b: eyeB }, procW, procH);

      // 7) 把三图绘制回主画布（放大到面板尺寸）
      const W = displayCanvas.width, H = displayCanvas.height;
      const panelW = Math.floor(W / 3);

      // target image (left)
      dctx.fillStyle = "#fff";
      dctx.fillRect(0, 0, panelW, H);
      // draw target from original scaled -> we used off canvas earlier
      dctx.drawImage(off, 0, 0, procW, procH, 0, 0, panelW, H);

      // middle: pre-warped (displayImgData)
      // draw displayImgData to temp canvas and draw scaled
      const tmp1 = document.createElement('canvas'); tmp1.width = procW; tmp1.height = procH;
      tmp1.getContext('2d').putImageData(displayImgData, 0, 0);
      dctx.fillStyle = "#fff"; dctx.fillRect(panelW, 0, panelW, H);
      dctx.drawImage(tmp1, 0, 0, procW, procH, panelW, 0, panelW, H);

      // right: eye-sim
      const tmp2 = document.createElement('canvas'); tmp2.width = procW; tmp2.height = procH;
      tmp2.getContext('2d').putImageData(eyeImg, 0, 0);
      dctx.fillStyle = "#fff"; dctx.fillRect(2 * panelW, 0, panelW, H);
      dctx.drawImage(tmp2, 0, 0, procW, procH, 2 * panelW, 0, panelW, H);

      // optional: overlay some text
      dctx.fillStyle = "rgba(0,0,0,0.6)";
      dctx.font = "14px sans-serif";
      dctx.fillText("目标（清晰）", 10, 20);
      dctx.fillText("预扭曲显示图", panelW + 10, 20);
      dctx.fillText("眼睛看到的模拟", 2 * panelW + 10, 20);
    }

    // 初始 UI 绘制
    drawUI();

  </script>
</body>

</html>